package decoder

import (
	"encoding/json"
	"fmt"
	"testing"

	"github.com/ofauchon/rfskipper-adapter/core"
)

func TestDecoder(t *testing.T) {

	testSignals := [2]string{
		`{"id":20,"count":75,"pulses":[480,3870,480,1970,460,1950,460,3940,480,1950,480,3850,450,1950,510,2020,460,3840,480,1930,480,1930,480,3910,490,1970,460,1950,450,3850,480,2000,480,1970,460,1950,460,1950,460,2020,480,3870,450,3850,480,3850,470,2000,480,3870,480,1930,480,1930,480,2000,480,1970,460,1920,480,1930,480,2000,480,1970,460,1950,460,1950,450,2000,480,1020,580]}`,
		`{"id":220,"count":303,"pulses":[210,210,210,210,210,200,210,210,210,200,220,200,210,210,210,200,210,420,620,630,210,200,210,210,420,410,210,200,430,410,210,210,210,200,210,210,210,200,210,210,210,200,210,210,420,410,220,200,210,210,210,200,210,210,420,200,210,210,210,420,200,210,210,210,210,200,210,210,210,200,210,210,210,200,430,410,210,210,410,210,210,200,210,210,210,210,210,410,420,210,210,410,420,200,210,420,420,410,210,210,420,200,210,210,210,410,210,210,420,410,210,210,210,200,420,410,210,210,210,200,420,210,210,210,210,410,420,210,210,410,210,200,210,210,420,210,210,200,220,200,210,410,210,210,420,200,210,210,210,410,420,420,410,420,210,200,210,210,210,200,220,200,220,200,210,210,210,200,210,210,210,200,420,420,210,200,210,210,210,200,220,200,210,200,220,200,210,210,210,200,210,210,210,210,210,200,210,210,210,200,220,200,210,210,210,200,220,200,210,210,210,200,210,210,210,200,210,210,210,200,220,200,210,210,210,200,220,200,210,210,210,200,210,210,210,200,210,210,210,210,210,210,410,210,210,200,220,410,210,200,210,210,210,210,210,200,210,210,210,200,220,200,420,410,210,210,210,200,210,210,220,200,210,200,220,200,420,410,420,420,410,210,210,210,210,200,210,210,210,200,210,420,410,420,420,200,220,410,210,200,210,210,80]}`,
	}

	p1 := NewPrologueDecoder()
	p2 := NewTicPulsesV2Decoder()

	for i, signal := range testSignals {

		var p core.PulseTrain
		err := json.Unmarshal([]byte(signal), &p)
		if err != nil {
			t.Error("#", i, " Can't unmmarshal json! ", err.Error())
		} else {

			fmt.Println(p1.Decode(p))
			fmt.Println(p2.Decode(p))
		}

	}

}
